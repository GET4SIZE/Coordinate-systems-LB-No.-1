# Coordinate-systems-LB-No.-1
Створення програмних моделей для представлення точок у 2D та 3D системах координат і проведення різних операцій.

## Короткий опис робот

Цей проект реалізує імутабельні (immutable) програмні моделі для представлення точок у 2D та 3D системах координат з використанням Python. Проект включає:

- **Імутабельні класи** для декартової, полярної та сферичної систем координат
- **Статичні фабричні методи** для перетворення між системами координат
- **Функції обчислення відстаней** між точками у різних представленнях
- **Бенчмарк-тести** для аналізу продуктивності різних підходів

### Реалізовані класи:

1. **CartesianPoint2D(x, y)** — точка у двовимірній декартовій системі
2. **PolarPoint(radius, angle)** — точка у полярній системі (2D)
3. **CartesianPoint3D(x, y, z)** — точка у тривимірній декартовій системі
4. **SphericalPoint(radius, azimuth, polar_angle)** — точка у сферичній системі (3D)

Всі класи є **імутабельними** (використовується `@dataclass(frozen=True)`), що гарантує незмінність стану після створення об'єкта.

---

## Інструкції для запуску проєкту

### Вимоги:
- Python 3.7 або новіший
- Стандартна бібліотека Python (без додаткових залежностей)

### Структура проекту:
```
.
├── coordinate_systems.py     # Класи систем координат
├── distances.py              # Функції обчислення відстаней
├── test_conversions.py       # Тести коректності перетворень
├── benchmark.py              # Бенчмарк продуктивності
└── main.py                   # Зручний запуск з меню
```

### Приклад використання в коді:
```python
from coordinate_systems import CartesianPoint2D, PolarPoint
from distances import distance_2d_cartesian

# Створення точок
p1 = CartesianPoint2D(3, 4)
p2 = CartesianPoint2D(6, 8)

# Перетворення у полярну систему
polar1 = PolarPoint.from_cartesian(p1)
print(polar1)  # PolarPoint(r=5.0000, θ=0.9273 rad)

# Обчислення відстані
dist = distance_2d_cartesian(p1, p2)
print(f"Відстань: {dist}")  # 5.0
```

---

## Результати перевірки коректності

Тести підтверджують правильність перетворень між системами координат. Всі перетворення (пряме та зворотне) відновлюють оригінальні координати з точністю до машинної похибки (< 10⁻¹⁰).

### Результат виводу тестів:

```
======================================================================
ТЕСТУВАННЯ 2D ПЕРЕТВОРЕНЬ
======================================================================

Тест 1:
  Оригінал (Декартова):  CartesianPoint2D(x=1.0000, y=0.0000)
  Перетворено (Полярна): PolarPoint(r=1.0000, θ=0.0000 rad)
  Назад (Декартова):     CartesianPoint2D(x=1.0000, y=0.0000)
  Похибка: x=0.00e+00, y=0.00e+00, max=0.00e+00
  Перетворення КОРЕКТНЕ

Тест 2:
  Оригінал (Декартова):  CartesianPoint2D(x=0.0000, y=1.0000)
  Перетворено (Полярна): PolarPoint(r=1.0000, θ=1.5708 rad)
  Назад (Декартова):     CartesianPoint2D(x=0.0000, y=1.0000)
  Похибка: x=6.12e-17, y=0.00e+00, max=6.12e-17
  Перетворення КОРЕКТНЕ

Тест 3:
  Оригінал (Декартова):  CartesianPoint2D(x=3.0000, y=4.0000)
  Перетворено (Полярна): PolarPoint(r=5.0000, θ=0.9273 rad)
  Назад (Декартова):     CartesianPoint2D(x=3.0000, y=4.0000)
  Похибка: x=4.44e-16, y=4.44e-16, max=4.44e-16
  Перетворення КОРЕКТНЕ

======================================================================
ТЕСТУВАННЯ 3D ПЕРЕТВОРЕНЬ
======================================================================

Тест 1:
  Оригінал (Декартова):   CartesianPoint3D(x=1.0000, y=0.0000, z=0.0000)
  Перетворено (Сферична): SphericalPoint(ρ=1.0000, θ=0.0000 rad, φ=1.5708 rad)
  Назад (Декартова):      CartesianPoint3D(x=1.0000, y=0.0000, z=0.0000)
  Похибка: x=0.00e+00, y=0.00e+00, z=6.12e-17, max=6.12e-17
  Перетворення КОРЕКТНЕ

Тест 4:
  Оригінал (Декартова):   CartesianPoint3D(x=3.0000, y=4.0000, z=5.0000)
  Перетворено (Сферична): SphericalPoint(ρ=7.0711, θ=0.9273 rad, φ=0.7854 rad)
  Назад (Декартова):      CartesianPoint3D(x=3.0000, y=4.0000, z=5.0000)
  Похибка: x=8.88e-16, y=0.00e+00, z=0.00e+00, max=8.88e-16
  Перетворення КОРЕКТНЕ

======================================================================
ПЕРЕВІРКА ЕКВІВАЛЕНТНОСТІ ВІДСТАНЕЙ
======================================================================

2D: Порівняння відстаней у декартовій та полярній системах
  Точка 1: CartesianPoint2D(x=1.0000, y=2.0000)
  Точка 2: CartesianPoint2D(x=4.0000, y=6.0000)
  Відстань (декартова): 5.000000
  Відстань (полярна):   5.000000
  Різниця: 0.00e+00
  Відстані СПІВПАДАЮТЬ

3D: Порівняння відстаней у декартовій та сферичній системах
  Точка 1: CartesianPoint3D(x=1.0000, y=2.0000, z=3.0000)
  Точка 2: CartesianPoint3D(x=4.0000, y=5.0000, z=6.0000)
  Відстань (декартова):      5.196152
  Відстань (сферична-хорда): 5.196152
  Різниця: 8.88e-16
  Відстані СПІВПАДАЮТЬ
```

**Висновок:** Всі перетворення працюють коректно, похибки знаходяться на рівні машинної точності.

---

## Результати аналізу продуктивності (Бенчмаркінг)

Бенчмарки виконані на 100,000 парах точок для кожного тесту.

### Таблиця результатів:

| Тип обчислення | Система координат | Метод | Час виконання (с) | Відносна швидкість |
|----------------|-------------------|-------|-------------------|--------------------|
| **2D** | Декартова | Евклідова відстань | **0.026905** | **Базова** |
| **2D** | Полярна | Теорема косинусів | 0.029892 | 1.11x повільніше |
| **3D** | Декартова | Евклідова відстань | **0.032883** | **Найшвидша** |
| **3D** | Сферична | Пряма відстань (хорда) | 0.049641 | 1.51x повільніше |
| **3D** | Сферична | Дугова відстань | 0.073739 | 2.24x повільніше |

### Повний вивід бенчмарку:

```
======================================================================
БЕНЧМАРК 2D (n = 100,000 пар точок)
======================================================================

Генерація тестових даних...
Згенеровано 100,000 пар точок

[A] Обчислення у полярних координатах (теорема косинусів)...
    Час виконання: 0.029892 секунд

[B] Обчислення у декартових координатах (евклідова відстань)...
    Час виконання: 0.026905 секунд

----------------------------------------------------------------------
РЕЗУЛЬТАТИ:
  Полярна:    0.029892 с
  Декартова:  0.026905 с
  Співвідношення (Polar/Cartesian): 1.11x
  Швидша система: Декартова (на 10.0%)

======================================================================
БЕНЧМАРК 3D (n = 100,000 пар точок)
======================================================================

Генерація тестових даних...
Згенеровано 100,000 пар точок

[A] Обчислення у сферичних координатах (пряма відстань - хорда)...
    Час виконання: 0.049641 секунд

[B] Обчислення у сферичних координатах (дугова відстань)...
    Час виконання: 0.073739 секунд

[C] Обчислення у декартових координатах (евклідова відстань)...
    Час виконання: 0.032883 секунд

----------------------------------------------------------------------
РЕЗУЛЬТАТИ:
  Сферична (хорда):  0.049641 с
  Сферична (дуга):   0.073739 с
  Декартова:         0.032883 с

  Рейтинг за швидкістю:
    1. Декартова: 0.032883 с
    2. Сферична (хорда): 0.049641 с
    3. Сферична (дуга): 0.073739 с

  Різниця між найшвидшою та найповільнішою: 2.24x
```

### Аналіз та висновки:

#### Для 2D:
- **Декартова система швидша на ~10%** порівняно з полярною
- **Причина:** Полярна формула використовує тригонометричну функцію `cos()`, яка є обчислювально дорожчою порівняно з простими арифметичними операціями (додавання, віднімання, множення)
- **Висновок:** Для обчислення відстаней у 2D краще використовувати декартову систему координат

#### Для 3D:
- **Декартова система найшвидша** (базова швидкість)
- **Сферична (хорда) повільніша у 1.51x** — використовує багато тригонометричних функцій (`sin`, `cos`)
- **Сферична (дуга) найповільніша у 2.24x** — додатково використовує `acos()`, що є найдорожчою операцією

**Причини різниці у продуктивності:**
1. **Тригонометричні функції** (`sin`, `cos`, `acos`) є набагато повільнішими за прості арифметичні операції
2. **Складність формул:** Чим більше тригонометричних обчислень, тим повільніше виконання
3. **Декартова система** використовує лише базові операції (додавання, віднімання, множення, квадратний корінь)

**Практичні рекомендації:**
- Якщо дані природно представлені у декартовій системі — використовуйте її для обчислень
- Якщо потрібна дугова відстань (геодезичні розрахунки) — конвертація неминуча, але варто враховувати додаткові витрати
- Для масових обчислень розгляньте попереднє кешування або векторизацію

---

## Загальний висновок

У процесі виконання лабораторної роботи були закріплені наступні навички:

1. **Проєктування імутабельних структур даних** з використанням Python dataclasses
2. **Реалізація математичних перетворень** між різними системами координат
3. **Застосування статичних фабричних методів** для конвертації об'єктів
4. **Написання автоматичних тестів** для перевірки коректності реалізації
5. **Бенчмаркінг та аналіз продуктивності** різних підходів

### Ключові інсайти:

-  **Імутабельність** спрощує розуміння коду та запобігає помилкам
-  **Тригонометричні функції** мають значний вплив на продуктивність
-  **Декартова система координат** найефективніша для обчислення відстаней
-  **Вибір системи координат** повинен базуватися на природі даних та типі операцій
-  **Бенчмаркінг** дозволяє приймати обґрунтовані рішення про оптимізацію

---

## Технічні деталі

### Використані формули:

**2D Перетворення:**
```
Полярна → Декартова:
  x = r · cos(θ)
  y = r · sin(θ)

Декартова → Полярна:
  r = √(x² + y²)
  θ = atan2(y, x)
```

**3D Перетворення:**
```
Сферична → Декартова:
  x = ρ · sin(φ) · cos(θ)
  y = ρ · sin(φ) · sin(θ)
  z = ρ · cos(φ)

Декартова → Сферична:
  ρ = √(x² + y² + z²)
  θ = atan2(y, x)
  φ = acos(z / ρ)
```

**Відстані:**
```
2D Декартова:
  d = √((x₂-x₁)² + (y₂-y₁)²)

2D Полярна:
  d = √(r₁² + r₂² - 2·r₁·r₂·cos(θ₂-θ₁))

3D Декартова:
  d = √((x₂-x₁)² + (y₂-y₁)² + (z₂-z₁)²)

3D Сферична (хорда):
  d = √(ρ₁² + ρ₂² - 2·ρ₁·ρ₂·[sin(φ₁)·sin(φ₂)·cos(θ₂-θ₁) + cos(φ₁)·cos(φ₂)])

3D Сферична (дуга):
  d = R · acos(sin(φ₁)·sin(φ₂)·cos(θ₂-θ₁) + cos(φ₁)·cos(φ₂))
```

---
